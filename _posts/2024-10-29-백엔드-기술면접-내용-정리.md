####  WAS(Web Application Server)와 WS(Web Server)의 차이를 설명해주세요 <br>
- WAS
    - 비즈니스 로직을 넣을 수 있다
    - Tomcat, PHP, ASP, .NET 등
- WS
    - 비즈니스 로직을 넣을 수 없음
    - Nginx, Apache 등

###  Spring Framework에 대해 설명해주세요 

-  스프링 프레임워크는 자바 개발을 편리하게 해주는 오픈소스 프레임워크 

-  경량 컨테이너로서 자바 객체를 직접 관리 
    - 각각의 객체 생성, 소멸과 같은 라이프 사이클을 관리하며 스프링으로부터 필요한 객체를 얻어로 수 있다.
    
-  제어의 역전(IoC)이라는 기술을 통해 어플리케이션의 느슨한 결합을 도모 
    - 컨트롤의 제어권이 사용자가 아닌 프레임워크에 있어서 필요에 따라 스프링에서 사용자의 코드를 호출한다.
-  의존성 주입(DI, Dependency Injection)을 지원 
    - 각각의 계층이나 서비스들 간에 의존성이 존재할 경우 프레임워크가 서로 연결시켜준다.
-  관점 지향 프로그래밍(AOP, Aspect-Oriented Programming)을 지원 
    - 트랜잭션이나 로깅, 보안과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리할 수 있다.


###  @RequestBody, @RequestParam, @ModelAttribute의 차이를 설명해주세요. <br>
@RequestBody <br>
- 클라이언트가 전송하는 JSON 형태의 HTTP Body 내용을 MessageConverter를 통해 Java Object로 변환시켜주는 역할을 한다.<br>
- 값을 주입하지 않고 값을 변환 시키므로 (Reflection을 사용해 할당), 변수들의 생성자, Getter, Setter가 없어도 정상적으로 할당된다.<br><br>
@RequestParam <br>
- 1개의 HTTP 요청 파라미터를 받기 위해 사용한다, @RequestParam은 필수 여부가 true이기 때문에 기본적으로 반드시 해당 파라미터가 전송되어야 한다.<br>
- 전송되지 않으면 404 Error를 유발할 수 있으며, 반드시 필요한 변수가 아니라면 required의 값을 false로 설정해줘야 한다.<br><br>
@ModelAttribute <br>
- HTTP Body 내용과 HTTP 파라미터의 값들을 생성자, Getter, Setter를 통해 주입하기 위해 사용한다.<br>
- 값 변환이 아닌 값을 주입기시므로 생성자, Getter, Setter가 없으면 변수들이 저장되지 않는다.<br>


###  Spring Boot와 Spring Framework의 차이점을 설명해주세요. 
- 가장 큰 차이점은 Auto Configuration의 차이인 것 같습니다. Spring은 프로젝트 초기에 다양한 환경설정을 해야 하지만,
- Spring Boot는 설정의 많은 부분을 자동화하여 사용자가 편하게 스프링을 활용할 수 있도록 돕습니다.
- spring boot starter dependency만 추가해주면 설정은 끝나고, 내장된 톰캣을 제공해 서버를 바로 실행할 수 있습니다.


###  Spring MVC에 대해 설명해주세요. 
- MVC는 Model, View, Controller의 약자이며, 각 레이어간 기능을 구분하는데 중점을 둔 디자인 패턴입니다.
-  Model 은 데이터 관리 및 비즈니스 로직을 처리하는 부분이며(DAO, DTO, Service 등)
-  View 는 비즈니스 로직의 처리 결과를 통해 유저 인터페이서가 표현되는 구간입니다. 
(html, jsp, thymeleaf, mustache 등 화면을 구성하기도 하고, Rest API로 서버가 구현된다면 json 응답으로 구성되기도 한다.)
-  Controller 는 사용자의 요청을 처리하고 Model과 View를 중개하는 역할을 합니다. Model과 View는 서로 연결되어 있지 않기 때문에 Controller가 사이에서 통신 매체가 되어줍니다.


###  MVC는 어떠한 흐름으로 요청을 처리하는지 설명해주세요 
DispatcherServlet  : 클라이언트에게 요청을 받아 응답까지의 MVC 처리과정을 통제한다.<br>
HandlerMapping  : 클라이언트의 요청 URL을 어떤 Controller가 처리할지 결정한다.<br>
HandlerAdapter  :HandlerMapping에서 결정된 핸들러 정보로 해당 메소드를 직접 호출해주는 역할을 한다.<br>
ViewResolver  : Controller의 처리 결과(데이터)를 생성할 view를 결정한다.<br>
1. 클라이언트는 URL을 통해 요청을 전송한다.
2. 디스패처 서블릿은 핸들러 매핑을 통해 해당 요청이 어느 컨트롤러에게 온 요청인지 찾는다.
3. 디스패처 서블릿은 핸들러 어댑터에게 요청의 전달을 맡긴다.
4. 핸들러 어댑터는 해당 컨트롤러에 요청을 전달한다.
5. 컨트롤러는 비즈니스 로직을 처리한 후에 반환할 뷰의 이름을 반환한다.
6. 디스패처 서블릿은 뷰 리졸버를 통해 반환할 뷰를 찾는다.
7. 디스패처 서블릿은 컨트롤러에서 뷰에 전달할 데이터를 추가한다.
8. 데이터가 추가된 뷰를 반환한다.

        
###  제어의 역전(IoC, Inversion of Control)에 대해 아는대로 설명해주세요. 
- 제어의 역전(IoC)란 모든 객체에 대한(생성, 라이프사이클 등) 제어권을 개발자가 아닌 IoC 컨테이너에게 넘긴것을 말합니다.
- 스프링에서는 IoC 컨테이너에 객체들을 생성하면 객체끼리 의존성을 주입하는 역할을하고 컨테이너에 등록한 객체들을 Bean이라고 합니다.
    

###  스프링에서 Bean을 등록하는 방법에 대해 말해보세요. 
1. 우선 가장 쉬운 방법으로 @Component 어노테이션을 사용하는 것입니다.
@Controller, @Service, @Repository는 모두 @Component를 포함하고 있습니다.
2. 설정 클래스를 따로 만들어 @Configuration 어노테이션을 붙이고,
해당 클래스 안에서 빈으로 등록할 메소드를 만들어 @Bean 어노테이션을 붙여주면 자동으로 해당 타입의 빈 객체가 생성됩니다.


###  의존성 주입(DI, Dependency Injection)에 대해 설명해주세요. 
- 의존성 주입은 필요한 객체를 직접 생성하는 것이 아닌 외부로부터 객체를 받아서 사용하는 것입니다.
- 이를 통해 객체간의 결합도를 줄이고 코드의 재사용성을 높일 수 있습니다.
- 의존성 주입은 생성자 주입, 필드 주입, 세터 주입의 3 가지 방법이 있습니다.
- 이 중 Spring에서 가장 권장하는 의존성 주입 방법은 생성자를 통한 주입 방법입니다
- 그 이유는 1. 순환 참조를 방지 2. 불변성을 가짐 3. 테스트에 용이하기 때문입니다.


###  스프링 빈의 생명주기는 어떻게 관리되는지 설명해주세요 
- 스프링 빈의 생명주기
    - 스프링 IoC 컨테이너 생성 → 스프링 빈 생성 → 의존관계 주입 → 초기화 콜백 메서드 호출 → 사용 → 소멸 전 콜백 메서드 호출 → 스프링 종료
- 3가지 방법 관리
    - 인터페이스(InitializingBean, DisposableBean)
    - 설정 정보에 초기화 메서드, 종료 메서드 지정
    - @PostConstruct, @PreDestory 애너테이션 지원


###  Spring Filter와 Interceptor에 대해 설명하고, 사용 예시를 설명해주세요 
- 필터는 요청과 응답을 거른 뒤 정제하는 역할을 한다.
- 스프링 컨테이너가 아닌 톰캣과 같은 웹 컨테이너에 의해 관리가 되는 것이고, 스프링 범위 밖에서 처리된다.
- Dispatcher Servlet에 요청이 전달되기 전 / 후에 url 패턴에 맞는 모든 요청에 대해 부가 작업을 처리할 수 있는 기능을 제공합니다.
- 사용 사례
    - 보안 및 인증/인가 관련 작업
    - 모든 요청에 대한 로깅 또는 검사
    - 이미지/데이터 압축 및 문자열 인코딩
    - Spring과 분리되어야 하는 기능
- 인터셉터는 요청에 대한 작업 전 / 후로 가로채 요청과 응답을 참조하거나 가공하는 역할을 합니다.
- 사용사례
    - 세부적인 보안 및 인증/인가 공통 작업
    - API 호출에 대한 로깅 또는 검사
    - Controller로 넘겨주는 정보(데이터)의 가공


###  관점지향 프로그래밍(Aspect Oriented Programming)는 무엇이고, 언제 사용할 수 있을까요 
- AOP는 핵심 비즈니스 로젝이 있는 공통 관심사항을 분리하여 각각을 모듈화 하는 것을 의미하며 공통 모듈인 인증, 로깅, 트랜잭션 처리에 용이합니다.
- 핵심 비즈니스 로직에 부가기능을 하는 모듈이 중복되어 분포되어 있을 경우 사용할 수 있습니다.
- AOP의 가장 큰 특징이자 장점은 중복 코드 제거, 재활용성의 극대화, 변화수용의 용이성이 좋다는 점입니다.


###  Lombok 라이브러리에 대해 알고 있나? Lombok이 만드는 메서드들이 생성되는 시점은 언제인가? 
- Lombok은 메서드를 컴파일하는 과정에 개입해서 추가적인 코드를 만들어낸다. 이것을 어노테이션 프로세싱이라고 하는데,
- 어노테이션 프로세싱은 자바 컴파일러가 컴파일 단계에서 어노테이션을 분석하고 처리하는 기법을 말한다.
- (Lombok 라이브러리를 추가할 때, CompileOnly, AnnotationProcessor를 추가하는 이유도 된다.)


###  서블릿(Servlet)에 대해 설명해주세요 
- 클라이언트의 요청을 처리하고, 그 결과를 반환하는 Servlet 클래스의 구현 규칙을 지킨 자바 웹 프로그래밍 기술.
- Spring MVC에서 Controller로 이용되며, 사용자의 요청을 받아 처리한 후에 결과를 반환한다.
- 간단히 - 자바를 사용해 웹을 만들기 위해 필요한 기술


###  서블릿의 동작 방식에 대해 설명해주세요 
1. 사용자(Client)가 URL을 입력하면 HTTP Request가 Servlet Container로 전송됩니다
2. 요청 받은 Servlet Container는 HttpServletRequest, HttpServletResponse 객체를 생성합니다.
3. web.xml을 기반으로 사용자가 요청한 URL이 어느 서블릿에 대한 요청인지 찾습니다.
4. 해당 서블릿에서 service메소드를 호출한 후 GET, POST여부에 따라 doGet() 또는 doPost()를 호출합니다.
5. doGet() or doPost() 메소드는 동적 페이지를 생성한 후 HttpServletResponse객체에 응답을 보냅니다.
6. 응답이 끝나면 HttpServletRequest, HttpServletResponse 두 객체를 소멸시킵니다.


###  VO와 BO, DAO, DTO에 대해 설명해주세요. 
- DAO(Data Access Object) DB의 데이터에 접근을 위한 객체를 말합니다. (Repository 또는 Mapper에 해당)
- BO(Business Object) 여러 DAO를 활용해 비즈니스 로직을 처리하는 객체를 말합니다. (Service에 해당)
- DTO(Data Transfer Object) 각 계층간의 데이터 교환을 위한 객체를 말합니다. (여기서 말하는 계층은 Controller, View, Business Layer, Persistent Layer)
- VO (Value Object) 실제 데이터만을 저장하는 객체를 말합니다.


###  대용량 트래픽에서 장애가 발생하면 어떻게 대응할 것인가요? 
- 스케일 업을 통해 하드웨어 스펙을 향상 / 스케일 아웃을 통해 서버를 여러대 추가해 시스템을 증가


###  Spring의 싱글톤 패턴에 대해 설명해주세요 
- 스프링에서 bean 생성 시 별다른 설정이 없으면 default로 싱글톤이 적용됩니다.
스프링은 컨테이너를 통해 직접 싱글톤 객체를 생성하고 관리하는데, 
요청이 들어올 때마다 매번 객체를 생성하지 않고, 이미 만들어진 객체를 공유하기 때문에 효율적인 사용이 가능합니다.
- 이를 통해 다음과 같은 장점을 얻을 수 있다.
    - static 메서드나 private 생성자 등을 사용하지 않아 객체지향적 개발을 할 수 있다.
    - 테스트하기 편리하다.


###  Spring의 스코프 프로토 타입 빈에 대해 설명 
- 프로토타입 빈은 싱글톤 빈과는 달리 컨테이너에게 빈을 요청할 때마다 매번 새로운 객체를 생성하여 반환해준다.
- 이렇게 빈의 scope를 간단하기 관리해줄 수 있는 것이 spring의 장점이다.
- 빈의 scope 설정은 @Scope 어노테이션으로 설정하며, 프로토타입 scope로 설정하려면 @Scope(”prototype”)와 같이 문자열로 지정해주면 된다.


###  @Transactional의 동작 원리에 대해 설명 
- @Transactional을 메서드 또는 클래스에 명시하면, AOP를 통해 Target이 상속하고 있는 인터페이스 또는 Target 객체를 상속한 Proxy 객체의 메서드를 호출하면 Target 메서드 전 후로 트랜잭션 처리를 수행한다.


###  @Transactional를 스프링 Bean의 메서드 A에 적용하였고, 해당 Bean의 메서드 B가 호출되었을 때, B 메서드 내부에서 A 메서드를 호출하면 어떤 요청 흐름이 발생하는지 설명 
- 프록시는 클라이언트가 타겟 객체를 호출하는 과정에만 동작하며, 타겟 객체의 메서드가 자기 자신의 다른 메서드를 호출할 때는 프록시가 동작하지 않습니다.
- 즉, A 메서드는 프록시로 감싸진 메서드가 아니므로 트랜잭션이 적용되지 않은 일반 코드가 수행됩니다.


###  A 라는 Service 객체의 메소드가 존재하고, 그 메소드 내부에서 로컬 트랜잭션 3개(다른 Service 객체의 트랜잭션 메소드를 호출했다는 의미)가 존재한다고 할 때, @Transactional을 A 메소드에 적용하면 어떤 요청 흐름이 발생하는지 설명해주세요. 
- 트랜잭션 전파 수준에 따라 달라지는데, 만약 기본 옵션인 Required를 가져간다면 로컬 트랜잭션 3개가 모두 부모 트랜잭션인 A에 합류하여 수행됩니다.
- 그래서 부모 트랜잭션이나 로컬 트랜잭션 3개나 모두 같은 트랜잭션이므로 어느 하나의 로직에서 문제가 발생하면 전부 롤백이 됩니다.


###  @Transacional에 readOnly 속성을 사용하는 이유에 대해서 설명 
- 트랜잭션 안에서 수정/삭제 작업이 아닌 ReadOnly 목적인 경우에 주로 사용하며, 영속성 컨텍스트에서 엔티티를 관리 할 필요가 없기 때문에 readOnly를 추가하는 것으로 메모리 성능을 높일 수 있고, 데이터 변경 불가능 로직임을 코드로 표시할 수 있어 가독성이 높아진다는 장점이 있다.
- readOnly 속성이 없는 보통의 트랜잭션은 데이터 조회 결과 엔티티가 영속성 컨텍스트에 관리되며,
이는 1차 캐싱부터 변경 감지(Dirty Checking)까지 가능하게 된다.
하지만, 조회시 스냅샷 인스턴스를 생성해 보관하기 때문에 메모리 사용량이 증가한다.


###  JPA N + 1 문제와 발생하는 이유 그리고 하결하는 방법을 설명 
- N+1이란 1번의 쿼리를 날렷을 때 의도하지 않은 N번의 쿼리가 추가적으로 실행되는 것을 의미한다.
- 가장 많이 사용되는 방법 Fetch Join을 사용하는 방법
    - N+1 문제가 발생하는 이유는 연관관계를 가진 엔티티를 조회할 때 한 쪽 테이블만 조회하고 연결된 다른 테이블은 따로 조회하기 때문인데,
    - Fetch Join을 사용하면 미리 두 테이블을 Join하여 한 번에 모든 데이터를 가져오기 때문에 N+1 문제를 애초에 막을 수 있다.


###  JPA와 같은 ORM을 사용하면서 쿼리가 복잡해지는 경우에는 어떻게 해결하는게 좋을까요? 
- 일단 JPA 자체는 정적인 상황에서 사용하는 걸 권장하기 때문에 복잡한 쿼리와 동적인 쿼리에 대한 문제가 발생하게 되는데,
- 그럴때는  JPQL 과  Querydsl 을 사용할 것을 권장하고 있다.

###  Java의 특징을 설명 
- 객체지향 프로그래밍 언어이다.
- 기본 자료형을 제외한 모든 요소들이 객체로 표현되고, 객제 지향 개념의 특징인 캡슐화, 상속, 다형성이 작 적용된 언어이다.
- 장점
    - JVM 위에서 동작하기 때문에 운영체제에 독립적이다.
    - GabageCollector를 통한 자동적인 메모리 관리가 가능하다.
- 단점
    - JVM 위에서 동작하기 때문에 실행 속도가 상대적으로 느리다.
    - 다중 상속이나 타입에 엄격하며, 제약이 많다.

###  JVM의 역할에 대해 설명 
- JVM은 스택 기반으로 동작하며, Java Byte Code를 OS에 맞게 해석해주는 역할을 하고 가비지 컬렉션을 통해 자동적인 메모리 관리를 해준다.

###  Java의 컴파일 과정에 대해 설명 
- 개발자가 java 파일을 생성한다.
- build를 한다.
- java compiler의 javac의 명령어를 통해 바이트코드(.class)를 생성한다.
- Class Loader를 통해 JVM 메모리 내로 로드한다.
- 실행엔진을 통해 컴퓨터가 잃을 수 있는 기계어로 해석된다.(각 운영체제에 맞는 기계어)

###  Java에서 제공하는 원시 타입들에 무엇이 있고, 각각 몇 바이트를 차지하나요? 
- 정수형 byte, short, int, long 실수형 float, double 문자형 char, 논리형 boolean
- 정수형 1, 2, 4, 8, 실수형 4, 8 문자형 2, 논리형 1 바이트를 차지한다.

###  Overriding과 Overloading에 대해 설명 
- 오버라이딩은 상위 클래스에 있는 메서드를 하위 클래스에서 재정의하는 것을 말하고
- 오버로딩은 매개변수의 개수나 타입을 다르게 하여 같은 이름의 메서드를 여러 개 정의하는 것을 말한다.

###  객체지향 프로그래밍(OOP)애 대해 설명 
- 우리가 실생활에서 쓰는 모든 것을 객체라 하며, 객체 지향 프로그래밍은 프로그램 구현에 필요한 객체를 하악하고 상태와 행위를 가진 객체를 만들고 각각의 객체들의 역할이 무엇인지를 정의하여 객체들 간의 상호작용을 통해 프로긂을 만드는 것을 말한다.
- 즉, 기능이 아닌 객체가 중심이며 “누가 어떤 일을 할 것인가?”가 핵심
- 특징으로는 캡슐화, 상속, 다형성, 추상화 등이 있고, 모듈 재사용으로 화장 및 유지보수가 용이하다.

###  try-with-resources에 대해 설명 
- try-with-resources는 try-catch-finally의 문제점을 보완하기 위해 나온 개년ㅁ
- try(…) 안에 자원 객체를 전달하면, try 블록이 끝나고 자동으로 자원 해제 해주는 기능을 말한다.
- 따로 finally 구문이나 모든 catch 구문에 종료 처리를 하지 않아도 되는 장점

###  불변 객체가 무엇인지 설명하고 대표적인 Java의 예시를 설명 
- 불변 객체는 객체 생성 이후 내부의 상태가 변하지 않는 객체를 말한다.
- Java에서는 필드가 원시 타입인 경우 final 키워드를 사용해 불변 객체를 만들 수 있고, 참조 타입일 경우엔 추가적인 작업이 필요

###  참조 타입일 경우 추가적인 작업은 어떤게 있는지 설명 
1. 객체를 참조
    1. 참조 변수가 일반 객체인 경우 객체를 사용하는 필드의 참조 변수도 별변 객체로 변경해야 한다.
2. 배열
    1. 배열을 받아 copy해서 저장하고, getter를 clone으로 반환하도록 하면된다.
    2. (배열을 그대로 참조하거나, 반환할 경우 외부에서 내부 값을 변경할 수 있음. 때문에 clone을 반환해 외부에서 값 변경하지 못하게 함)
3. List
    1. 배열과 마찬가지로 생성 시 새로운 List를 만들어 값을 복사하도록 해야한다.
    2. 배열과 리스트는 내부를 복사하여 전달하는데, 이를 방어적 복사라고 한다.

###  불변 객체나 final을 굳이 사용해아 하는 이유가 있을까? 
- 불변 객체나 final 키워드를 사용해 얻는 이점은 다음과 같습니다.
1. Thread-Safe하여 병렬 프로그래밍에 유용하며, 동기화를 고려하지 않아도 된다.
(공유 자원이 불변이기 때문에 항상 동일한 값을 반환하기 때문)
2.  실패 원자적인 메소드를 만들 수 있다.
(어떠한 예외가 발생되더라도 메소드 호출 전의 상태를 유지할 수 있어 예외 발생 전과 똑같은 상태로 다음 로직 처리 가능)
3. 부수효과를 피해 오류를 최소화 할 수 있다.
※ 부수효과 : 변수의 값이 바뀌거나 객체의 필드 값을 설정하거나 예외나 오류가 발생하여 실행이 중단되는 현상
4. 메소드 호출 시 파라미터 값이 변하지 않는다는 것을 보장할 수 있다.
5. 가비지 컬렉션 성능을 높일 수 있다.
(가비지 컬렉터가 스캔하는 객체의 수가 줄기 때문에 Gc 수행 시 지연시간도 줄어든다.)

###  추상 클래스와 인터페이스를 설명하고 차이점에 대해 설명 
- 추상 클래스
    - 클래스 내 추상 메서드가 하나 이상 포함되거나 abstract로 정의된 경우
- 인터페이스
    - 모든 메서드가 추상 메서드로만 이루어져 있는 것
- 공통점
    - new 연산자로 인스턴스 생성 불가능
    - 사용하기 위해서는 하위 클래스에서 확장/구현해야한다.
- 차이점
    - 인터페이스는 그 인터페이스를 구현하는 모든 클래스에 대해 특정한 메서드가 반드시 존재하도록 강제함에 있고,
    - 추상클래스는 상속받는 클래스들의 공통적인 로직을 추상화 시키고, 기능 확장을 위해 사용한다.
    - 추상클래스는 다중상속이 불가능하지만, 인터페이스는 다중상속이 가능.

###  싱글톤 패턴에 대해 설명 
- 단 하나의 인스턴스를 생성해 사용하는 디자인 패턴
- 인스턴스가 1개만 존재해야 한다는 것을 보장하고 싶은 경우와 동일한 인스턴스를 자주 생성해양 하는 경우에 주로 사용한다 (메모리 낭비 방지)

###  싱글톤 패턴의 대표적인 예시를 간단하게 설명 
- 싱글톤 패턴의 대표적인 예시는 Spring Bean입니다.
- 스프링의 빈 등록 방식은 기본적으로 싱글톤 스코프이고, 스프링 컨테이너는 모든 빈들을 싱글톤으로 관리합니다.
- 스프링은 요청할 때마다 새로운 객체를 생성해서 반환하는 기능도 제공한다. (프로토타입 빈, @Scope("prototype"))

###  가비지 컬렉션(Garbage Collection)에 대해 설명 
- 가비지 컬렉션은 JVM의 메모리 관리 기법 중 하나로 시스템에서 동적으로 할당됐던 메모리 영역 중에서 필요없어진 메모리 영역을 회수하여 메모리를 관리해주는 기법

###  가비지 컬렉션 과정에 대해 설명 
- GC의 작업을 수행하기 위해 JVM이 어플리케이션의 실행을 잠시 멈추고, GC를 실행하는 스레드를 제외한 모든 스레들의 작업을 중단 후 (Stop The World 과정) 사용하지 않는 메모리를 제거 (Mark and Sweep 과정)하고 작업이 재개됩니다.

###  객체지향의 설계원칙(SOLID)에 대해 설명 
- SRP (단일 책임 원칙) : 한 클래스는 하나의 책임만 가져야 한다.
- OCP (개방-폐쇄 원칙) : 확장에는 열려있고, 수정에는 닫혀있어야 한다.
- LSP (리스코프 치환 원칙) : 하위 타입은 항상 상위 타입을 대체 할 수 있어야 한다.
- ISP (인터페이스 분리 원칙) : 인터페이스 내에 메서드는 최소한일수록 좋다.
- DIP (의존관계 역전 원칙) : 구체적인 클래스보다 상위 클래스, 인터페이스, 추상클래스와 같이 변하지 않을 가능성이 높은 클래스와 관계를 맺어라
DIP 원칙을 따르는 가장 인기 있는 방법은 의존성 주업(DI)이다.

###  자바의 메모리 영역에 대해 설명 
- 메서드(Method) 영역 : 전역변수와 static 변수를 저장하며, Method 영역은 프로그램의 시작부터 종료까지 메모리에 남아있다.
- 스택(Stack) 영역 : 지역변수와 매개변수 데이터 값이 저장되는 공간이며, 메서드가 호출될 때 메모리에 할당되고 종료되면 메모리가 해제된다. LIFO 구조를 갖고 변수에 새로운 데이터가 할당되면 이전 데이터는 지워진다.
- 힙(Heap) 영역 : new 키워드로 생성되는 객체(인스턴스), 배열 등이 Heap 영역에 저장되며, 가비지컬렉션에 의해 메모리가 관리되어 진다.

###  각 메모리 영역이 할당되는 시점은 언제인가? 
- Method 영역 : JVM이 동작해서 클래스가 로딩될 때 생성
- Stack 영역 : 메서드가 호출될 때 할당
- Heap 영역 : 런타임시 할당

###  클래스와 객체에 대해 설명 
- 클래스는 객체를 만들어내기 위한 설계도 혹은 틀이라고 할 수 있고, 객체를 생성하는데 사용
- 객체는 설계도(클래스)를 기반으로 생성되며, 자신의 고유 이름과 상태, 행동을 갖습니다.
- 여기서 상태는 필드(fields), 행동은 메서드(Method)라고 표현한다.
- 객체에 메모리가 할당되어 실제로 활용되는 실체는 ‘인스턴스’라고 부른다.

###  생성자(Constructor)에 대해 설명 
- 생성자는 클래스와 같은 이름의 메서드로, 객체가 생성될 때 호출되는 메서드이다.
- 명시적으로 생성자를 만들지 않아도 default로 만들어지며, 생성자는 파라미터를 다르게하여 오버로딩할 수 있다.

###  Wrapper Class란 무엇이며, Boxing과 UnBoxing은 무엇인지 설명 
- 기본 자료형(Primitive data type)에 대핸 객체 표현을 Wrapper Class라고 한다.
- 기본 자료형 → Wrapper Class로 변환하는 것을 Boxing
- Wrapper Class → 기본 자료형으로 변환하는 것을 UnBoxing

###  Synchronized에 대해 아는 대로 말해주세요 
- 여러 개의 스레드가 한 개의 자원을 사용하고자 할 때, 현재 데이터를 사용하고 있는 스레드를 제외하고 나머지 스레드들은 데이터에 접근할 수 없게 막는 개념이다.
- 데이터의 thread-safe를 하기 위해 자바에서 Synchronized 키워드를 제공해 멀티 스레드 환경에서 스레드간 동기화를 시켜 데이터의 thread-safe를 보장
- Synchronized는 변수와 메서드에 사용해서 동기화 할 수 있으며, Synchronized 키워드를 남발하기 되면 오히려 프로그램의 성능저하를 일으킬 수 있습니다.

###  new String()과 리터럴(””)의 차이에 대해 설명해주세요 
- new String()은 new 키워드로 새로운 객체를 생성하기 때문에 Heap 메모리 영역에 저장
- “”는 Heap 안에 있는 String Constant Pool 영역에 저장

###  String, StringBuffer, StringBuilder의 차이를 설명 
- String은 불변의 속성을 가지며, StringBuffer와 StringBuilder는 가변의 속성을 가진다.
- StringBuffer는 동기화를 지원하여 멀티 스레드 환경에서 주로 사용
- StringBuilder는 동기화를 지원하지 않아 싱글 스레드 환경에서 주로 사용

###  String 객체가 불변인 이유에 대해 아는대로 설명 
1.  캐싱 기능에 의한 메모리 절약과 속도 향상 
    1. Java에서 String 객체들은 HEap의 String Pool이라는 공간에 저장되는데, 참조하려는 문자열이 String Pool에 존재하는 경우 새로 생성하지 않고 Pool에 있는 객체를 사용하기 때문에 특정 문자열 값을 재사용하는 빈도가 높을 수록 상당한 성능 향상을 기대할 수 있다.
2.  thread-safe 
    1. String 객체는 불변이기 때문에 여러 스레드에서 동시에 특정 String 객체를 참조하더라도 안전하다.
3.  보안기능 
    1. 중요한 데이터를 문자열로 다루는 경우 갖에로 해당 참조에 대한 문자열 값을 바꾸는 것이 불가능하기 때문에 보안에 유리하다.

###  접근 제한자(Access Modifier)에 대해 설명 
- 변수 또는 메서드의 접근 범위를 설정해주기 위해서 사용하는 Java의 예약어를 의미
- public - 접근 제한이 없다
- protected - 해당 패키지 내, 다른 패키지에서 상속받아 자손 클래스에서 접근 가능
- (default) - 해당 패키지 내에서만 접근 가능
- private - 해당 클래스에서만 접근 가능

###  클래스 멤버 변수 초기화 순서에 대해 설명 
1. static 변수 선언부 : 클래스가 로드 될 때 변수가 제일 먼저 초기화 된다.
2. 필드 변수 선언부 : 객체가 생성될 때 생성자 block 보다 앞서 초기화 된다.
3. 생성자 block : 객체가 생성될 때 JVM이 내부적으로 locking (thead-safe 영역)

###  static에 대해 설명 
- static 키워드를 사용한 변수나 메서드는 클래스가 메모리에 올라갈 떄 자동으로 생성되며 클래스 로딩이 끝나면 바로 사용할 수 있다. 즉, 인스턴스(객체) 생성 없이 바로 사용 가능합니다.
- 모든 객체가 메모리를 공유한다는 특징이 있고, GC 관리 영역 밖에 있기 때문에 프로그램이 종료될 때까지 메모리에 값이 유지된 채로 존재하게 된다.

###  static을 사용하는 이유에 대해 설명 
- static은 자주 변하지 않는 값이나 공통으로 사용되는 값 같은 공용자원에 대한 접근에 있어서 매번 메모리에 로딩하거나 값을 읽어들이는 것보다 일종의 ‘전역변수’와 같은 개념을 통해 접근하는 것이 비용도 줄이고 효율을 높일 수 있다.
- 인스턴스 생성없이 바로 사용 가능하기 때문에 프로그램 내에서 공통으로 사용되는 데이터들을 관리할 때 이용

###  Inner Class(내부 클래스)의 장점에 대해 설명 
1. 내부 클래스에서 외부 클래스의 멤버에 손쉽게 접근할 수 있다.
2. 서로 관련 있는 클래스를 논리적으로 묶어서 표현함으로써, 캡슐화를 증가시키고, 코드의 복잡성을 낮출 수 있다.
3. 외부에서는 내부 클래스에 접근할 수 없으므로, 코드의 보안성을 높을 수 있다.

###  리플렉션(Reflection)이란 무엇인지 설명 
- 리플렉션이란 구체적인 클래스 타입을 알지 못해도 그 클래스의 메서드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API입니다.

###  Reflection은 어떤 경우에 사용되는지 설명 
- 코드를 작성할 시점에는 어떤 타입의 클래스를 사용할지 모르지만, 런타입 시점에 지금 실행되고 있는 클래스를 가져와서 실행해야 하는 경우 사용된다.
- 프레임워크나 IDE에서 이런 동적인 바인딩을 이용한 기능을 제공합니다. IntelliJ의 자동완성 기능, 스프링의 어노테이션의 리플렉션을 잉요한 기능이라 할 수 있다.

###  Error와 Exception의 차이를 설명 
- Error는 실행 중 일어날 수 있는 치명적 오류, 컴파일 시점에 체크할 수 없고, 오류가 발생하면 프로그램은 비정상 종료되며 예측 불가능한 UncheckedException에 속한다.
- Exception은 Error보다 비교적 경미한 오류이며, try-catch를 이용해 프로그램의 비정상 종료를 막을 수 있다.

###  CheckedException과 UnCheckedExcpetion의 차이를 설명 
- CheckedExcpetion은 실행하기 전에 예측 가능한 예외를 말하고, 반드시 예외 처리르 해야 한다.
    - 대표적인 Excpetion - IOExcpetion, ClassNotFoundException 등
- UnCheckedExcpetion은 실행하고 난 후에 알 수 있는 예외를 말하고, 따로 예외처리를 하지 않아도 된다.
    - 대표적인 Exception - NullPointerException, ArrayIndexOutOfBoundException 등
- RuntimeException은 UncheckedException을 상속한 클래스이고, RuntimeException이 아닌 것은 CheckedException을 상속한 클래스.

###  Optional API에 대해 설명 
- 개발할 때 가장 많이 발생하는 예외 중 하나가 NPE(NullPointerException)이다.
- NPE를 피하려면 null 여부 검사를 필연적으로 하게 되는데 만약 null 검사를 해야하는 변수가 많은 경우 코드가 복잡하고 번거롭다.
- 하지만 Java8부터 Optional<T>를 제공하여 null로 인한 예외가 발생하지 않도록 도와주고, Optional 클래스의 메서드를 통해 null를 컨트롤 할 수 있다.

###  컬렉션 프레임워크에 대해 설명 
- 다수의 데이터를 쉽고 효과적으로 관리할 수 있는 표준화된 방법을 제공하는 클래스의 집합을 의미한다.
- 자바 컬렉션에는 List, Set, Map 인터페이스를 기준으로 여러 구현체가 존재하고, 이에 더해 Stack, Queue 인터페이스도 존재한다.

###  List, Set, Map, Stack, Queue의 특징에 대해 설명 
- List는 순서가 있는 데이터의 집합이며, 데이터의 중복을 허용합니다. 대표적인 구현체로는 ArrayList가 있고, 이는 Vector를 개선한 것입니다. 이외에도 LinkedList 등의 구현체가 있습니다.
    - Vector, ArrayList, LinkedList, Stack, Queue
- Set은 순서가 없는 데이터의 집합이며, 데이터의 중복을 허용하지 않습니다. 대표적인 구현체로는 HashSet이 있고, 순서를 보장하기 위해서는 LinkedHashSet을 사용합니다. (Map의 key-value 구조에서 key 대신 value가 들어가 value를 key로 하는 자료구조)
    - HashSet, LinkedHashSet, TreeSet
- Map은 키와 값이 한 쌍으로 이뤄져 있고, 키를 기준으로 중복을 허용하지 않으며, 순서가 없습니다. key의 순서를 보장하기 위해서는 LinkedHashMap을 사용합니다.
    - HashMap, TreeMap, HashTable, Properties
- Stack 객체는 직접 new 키워드로 사용할 수 있으며, 
Queue 인터페이스는 LinkedList에 new 키워드를 적용해 사용할 수 있습니다.

###  Set과 Map의 타입이 Wrapper Class가 아닌 Object를 받을 때 중복 검사는 어떻게 할건지 설명 
- hashCode() 메소드를 오버라이딩하여 리턴된 해시코드 값이 같은지를 보고 해시코드 값이 다르다면 다른 객체로 판단하고,
해시코드 값이 같으면 equals() 메소드를 오버라이딩하여 다시 비교합니다. 
이 두 개가 모두 맞으면 중복 객체입니다.


###  Vector와 List의 차이를 설명 
- 벡터는 데이터 삽입시 원소를 밀어내지만 리스트는 노드를 연결만 하기 때문에, 삽입 삭제 부분에서 리스트가 시간복잡도의 우위를 가집니다.
- 벡터는 랜덤부분접근이 가능하지만 리스트는 더블링크드리스트(노드가 양쪽으로 연결)로 되어있기 때문에 랜덤 접근이 되지 않습니다. 
검색적인 측면에서는 벡터가 우위에 있습니다.
- 벡터는 리스트와 달리 항상 동기화되는 장점이자 단점을 가지고 있습니다. 
멀티 쓰레드 환경에서 안전하게 객체를 추가하고 삭제할 수 있지만, 단일쓰레드 환경 일때도 동기화를 하기 때문에 List보다 성능이 떨어집니다.

###  제네릭에 대해 설명, 왜 쓰는지? 
- 제네릭은 데이터의 타입을 하나로 지정하지 않고 사용할 때마다 범용적이고 포괄적으로 지정한다는 의미입니다.
- 제네릭 타입을 사용함으로써 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있어 에러를 사전에 방지할 수 있습니다.

###  final / finally / finalize의 차이를 설명 
- final은 클래스, 메소드, 변수, 인자를 선언할 때 사용할 수 있으며, 한 번만 할당하고 싶을 때 사용합니다.
    - final 변수는 한 번 초기화되면 그 이후에 변경할 수 없습니다.
    final 메소드는 다른 클래스가 이 클래스를 상속할 때 메소드 오버라이딩을 금지합니다.
    final 클래스는 다른 클래스에서 이 클래스를 상속할 수 없습니다.
- finally는 try-catch와 함께 사용되며, try-catch가 종료될 때 finally block이 항상 수행되기 때문에 마무리 해줘야 하는 작업이 존재하는 경우에 해당하는 코드를 작성해주는 코드 블록입니다.
- finalize는 Object 클래스에 정의되어 있는 메소드이며, GC에 의해 호출되는 메소드로 절대 호출해서는 안되는 메소드입니다. 
GC가 발생하는 시점이 불분명하기 때문에 해당 메소드가 실행된다는 보장이 없고, finalize() 메소드가 오버라이딩 되어 있으면 GC가 이루어질 때 바로 Garbage Collectiong 되지 않습니다. 
GC가 지연되면서 OOME(Out of Memory Exception)이 발생할 수 있기 때문에 finalize() 메소드를 오버라이딩하여 구현하는 것을 권장하지 않고 있습니다.

###  직렬화(Serialize)에 대해 설명 
- 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 시스템에서도 사용할 수 있도록 바이트(byte) 형태로 데이터 변환하는 기술이며, 
반대로 직렬화된 바이트 형태의 데이터를 다시 객체로 변환하는 과정을 '역직렬화'라고 합니다
- (간단히) JVM의 메모리에 상주(힙 or 스택)되어 있는 객체 데이터를 바이트 형태로 변환하는 기술

###  SerialVersionUID를 선언해야 하는 이유에 대해 설명 
- JVM은 직렬화와 역직렬화를 하는 시점의 클래스에 대한 버전 번호를 부여하는데, 
만약 그 시점에 클래스의 정의가 바뀌어 있다면 새로운 버전 번호를 할당하게 됩니다. 
그래서 직렬화할 때의 버전 번호와 역직렬화를 할 때의 버전 번호가 다르면 역직렬화가 불가능하게 될 수 있기 때문에 
이런 문제를 해결하기 위해 SerialVersionUID를 사용합니다.
- 만약 직렬화할 때 사용한 SerialVersionUID의 값과 역직렬화 하기 위해 사용했던 SVUID가 다르다면 InvalidClassException이 발생할 수 있다.

###  데이터베이스의 특징에 대해 설명 
- 실시간 접근성(Real-Time Accessibility)
    - 비정형적인 질의(조회)에 대하여 실시간 처리에 의한 응답이 가능해야 함.
- 지속적인 변화(Continuous Evloution)
    - 데이터베이스의 상태는 동적입니다. 즉 새로운 데이터의 삽입, 삭제, 갱신으로 항상 최신의 데이터를 유지해야 한다.
- 동시 공용(Concurrent Sharing)
    - 데이터베이스는 서로 다른 목적을 가진 여러 응용자들을 위한 것이므로 다수의 사용자가 동시에 같은 내용의 데이터를 이용할 수 있어야 한다.
- 내용에 의한 참조(Content Reference)
    - 데이터베이스에 있는 데이터를 참조할 때 데이터 레코드의 주소나 위치에 의해서가 아니라 사용자가 요구하는 데이터 내용으로 찾습니다.

###  데이터베이스 언어(DDL, DML, DCL)에 대해 설명 
- Data Definition Language
    - 데이터베이스 구조를 정의, 수정, 삭제하는 언어(alter, create, drop)
- Data Manipulation Language
    - 데이터베이스 내의 자료 검색, 삽입, 갱신, 삭제를 위한 언어(select, insert, update, delete)
- Data Control Language
    - 데이터에 대해 무결성 유지, 병행 수행 제어, 보호와 관리를 위한 언어(commit, rollback, grant, revoke)

###  SELECT 쿼리의 수행 순서 
- FROM, ON JOIN → WHERE, GROUP BY, HAVING → SELECT → DISTINCT → ORDER BY → LIMIT

###  트리거(Trigger)에 대해 설명 
- 트리거는 특정 테이블에 대한 이벤트에 반응해 INSERT, DELETE, UPDATE 같은 DML 문이 수행되었을 때, 데이터베이스에서 자동으로 동작하도록 작성된 프로그램.
- 사용자가 직접 호출하는 것이 아닌, 데이터베이스에서 자동적으로 호출한다는 것이 가장 큰 특징.

###  Index에  대해 설명해주시고, 장/단점에 대해 아는대로 말해주세요 
- Index란 테이블을 처음부터 끝까지 검색하는 방법인 Full Table Scan과는 달리 인덱스를 검색하여 해당 자료의 테이블을 엑세스 하는 방법.
- 인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 검색하는 데 빠르지만, 새로운 값을 추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려진다.
- 즉, 인덱스는 데이터의 저장 성능을 희생하고 그 대신 데이터의 검색 속도를 높이는 기능이라 할 수 있다.

###  DBMS는 Index를 어떻게 관리하고 있나요? (Index 자료구조) 
- B+Tree 인덱스 자료구조
    - 자식 노드가 2개 이상인 B-Tree를 개선시칸 자료구조이며 BTree 리프노드들을 LinkedList로 연결하여 순차 검색을 용이하게 한다.
    - 해시 테이블보다 나쁜 O(log2N)의 시간복잡도를 갖지만 일반적으로 사용되는 자료구조이다.
- 해시 테이블
    - 컬럼의 값으로 생성된 해시를 기반으로 인덱스를 구현한다.
    - 시간복잡도가 O(1)이라 검색이 매우 빠르다.
    - 부동호와 같은 연속적인 데이터를 위한 순차 검색이 불가능하기 때문에 사용에 적합하지 않는다.

###  정규화에 대해 설명 
- 하나의 릴레이션에 하나의 의미만 존재하도록 릴레이션을 분해하는 과정이며, 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법
- 제 1 정규형 : 테이블의 컬럼이 원자 값(Atomic Value)을 갖도록 분해한다.
- 제 2 정규형 : 기본키가 아닌 속성이 기본키에 완전 함수 종속이도록 분해한다.
- 제 3 정규형 : 이행적 함수 종속을 없애도록 분해한다.
- BCNF 정규형 : 함수 종속성 X → Y가 성립할 때 모든 결정자 X가 후보키가 되도록 분해한다.

###  정규화에는 어떤 장점이 있고 어떤 단점이 있는지 설명 
장점
- 데이터베이스 변경 시 이상현상이 발생하는 문제점을 해결할 수 있다.
- 데이터베이스 구조 확장 시 정규화된 데이터베이스는 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다.

단점
- 릴레이션의 분해로 인해 릴레이션 간의 연산(Join 연산)이 많아진다. 이로인해 질의에 대한 응답 시간이 느려질 수 있다.

### 역정규화를 하는 이유에 대해 설명
- 정규화를 거치면 릴레이션 간의 연산이 많아지는데, 이로인해 성능이 저하될 우려가 있다.
- 역정규화를 하는 가장 큰 이유는 성능 문제가 있는 (읽기작업이 많이 필요한) DB의 전반적인 성능을 향상시키기 위함이다.

###  이상 현상의 종류에 대해 설명 
테이블을 설계할 때 잘못 설계하여 데이터를 삽입, 삭제, 수정할 때 생기는 논리적 오류를 말한다.<br>
- 삽입 이상 : 자료를 삽입할 때 특정 속성에 해당하는 값이 없어 NULL을 입력해야 하는 현상
- 갱신 이상 : 중복된 데이터 중 일부만 수정되어 데이터  모순이 일어나는 현상
- 삭제 이상 : 어떤 정보를 삭제하면, 의도
하지 않은 다른 정보까지 삭제되어버리는 현상

###  SQL Injection이 무엇인지 설명 
SQL Injection이란 공격자가 악의적인 의도를 갖는 SQL 구문을 삽입하여 데이터베이스를 비정상적으로 조작하는 코드 인젝션 공격 기법이다.

###  SQL Injection을 방어 및 방지하기 위한 방법에 대한 설명 
- 입력값을 검증하여 사용자의 입력이 쿼리에 동적으로 영향을 주는 경우 입력된 값이 개발자가 의도한 값인지 검증한다.
- 저장 프로시저를 사용한다.
    - 사용하고자 하는 Query에 미리 형식을 지정하는 것을 말한다. 지정된 형식의 데이터가 아니면 Query가 실행되지 않기 때문에 보안성이 크게 향상한다.

###  RDBMS와 NoSQL의 차이에 대해 설명 
- RDBMS는 모든 데이터를 2차원 테이블 형태로 표현한다.
    - 장점 : 스키마에 맞춰 데이터를 관리하게 때문에 데이터의 정합성을 보장할 수 있다.
    - 단점 : 시스템이 커질 수록 쿼리가 복잡햊고 성능이 저하되며 Scale-out이 어렵다(Scale-up만 가능)
- Not Only SQL은 RDBMS와 반대로 데이터간의 관계를 정의하지 않고, 스키마가 없어 좀 더 자유롭게 데이터를 관리할 수 있으며, 컬렉션이라는 형태로 데이터를 관리한다.
    - 장점 : 스키마 없이 Key-Value 형태로 데이터를 관리해 자유롭게 데이터를 관리할 수 있다.
                데이터 분산이 용이하여 성능 향상을 위한 scale-up 뿐만 아닌 scale-out 또한 가능하다.
    - 단점 : 데이터 중복이 발생할 수 있고, 중복된 데이터가 변경될 경우 수정을 모든 컬렉션에서 수행해야한다.
                스키마가 존재하지 않기에 명확한 데이터 구조를 보장하지 않아 데이터 구조 결정이 어려울 수 있다.

###  RDBMS와 NoSQL은 어느 경우에 적합한지 
- RDBMS
    - 데이터 구조가 명확하고, 변경 될 여지가 없으며 스키마가 중요한 경우 사용하는 것이 좋다.
    또한 중복된 데이터가 없어(데이터 무결성) 변경이 용이하기 때문에 관계를 맺고 있는 데이터가 자주 변경이 이루어지는 시스템에 적합하다.
- NoSQL
    - 정확한 데이터 구조를 알 수 없고 데이터가 변경/확장 될 수 있는 경우 사용하는 것이 좋다.
    또한 단점에서도 명확하듯 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경될 시 모든 컬렉션에서 수정해야 하기 때문에 Update가 많이 이루어지지 않는 시스템에 좋으며, Scale-out이 가능하다는 장점을 활용해 막대한 데이터를 저장해야 해서 DB를 Scale-out 해야 되는 시스템에 적합하다.

###  트랜잭션이란 무엇인지 설명 
- 트랜잭션은 작업의 완전성을 보장해준다.
- 작업들을 모두 처리하거나 처리하지 못할 경우 이전 상태로 복구하여 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능이다.
- 하나의 트랜잭션은 Commit되거나 Rollback된다.

###  트랜잭션의 특성(ACID)에 대해 설명 
-  원자성(Atomicity)  : 작업이 모두 반영되던지 아니면 전혀 반영되지 않아야 한다.
-  일관성(Consistency)  : 실행이 완료되면 언제나 일관성 있는 상태를 유지해야 한다.
-  독립성(Isolation)  : 둘 이상 트랜잭션이 동시에 실행될 경우 서로의 연산에 끼어들 수 없다.
-  영속성(Durability)  : 완료된 결과는 영구적으로 반영되어야 한다.

###  DB Lock에 대한 설명 
- 트랜잭션 처리의 순차성을 보장하기 위한 방법이다.
- 공유락(Shared Lock) : 트랜잭션이 읽기를 할 때 사용하는 락이며, 데이터를 읽기만 하기 때문에 같은 공유락 끼리는 동시에 접근이 가능하다.
- 베타락(Exclusive Lock) : 데이터를 변경할 때 사용하는 락이며, 트랜잭션이 완료될 때까지 유지되며, 베타락이 끝나기 전까지 어떠한 접근도 허용하지 않는다.

###  Elastic Search의 키워드 검색과 RDBMS의 LIKE 검색의 차이에 대한 설명 
- RDBMS는 단순 텍스트매칭에 대한 검색만을 제공해 동의어나 유의어 같은 검색은 불가능하다.
- Elastic Search는 동의어나 유의어를 활용한 검색이 가능하며, 비정형 데이터의 색인과 검색이 가능하고, 역색인 지원으로 매우 빠른 검색이 가능하다.

###  옵티마이저(Optimizer)에 대해 아는대로 설명 
- SQL을 가장 빠르고 효율적으로 수행할 최적의 처리 경로를 생성해주는 DBMS 내부의 핵심엔진이다.
- 컴퓨터의 두뇌가 CPU인 것처럼 DBMS의 두뇌는 옵티마이저라고 할 수 있다.
개발자가 SQL을 작성하고 실행하면 즉시 실행되는 것이 아니라 옵티마이저라는 곳에서 “이 쿼리문을 어떻게 실행시키겠다!”라는 여러가지 실행 계획을 세우고, 
최고의 효율을 갖는 실행계획을 판별한 후 그 실행계획에 따라 쿼리를 수행하게 되는 것이다.


###  DB 튜닝(Tuning)이 무엇인지 그리고 튜닝의 3단계에 대한 설명 
DB의 구조나, DB 자체, 운영체제 등을 조정하여 DB 시스템의 전체적인 성능을 개선하는 작업을 말한다.
1. DB 설계 튜닝
    - DB 설계 단계에서 성능을 고려하여 설계
    - 데이터 모델링, 인덱스 설계
    - 데이터파일, 테이블 스페이스 설계
    - 데이터베이스 용량 산정
    - 튜닝 사례 - 반정규화, 분산파일배치
2. DBMS 튜닝
    - 성능을 고려하여 메모리나 블록 크기 지정
    - CPU, 메모리 I/O에 관한 관점
    - 튜닝 사례 - Buffer 크기, Cache 크기
3. SQL 튜닝
    - SQL 작성 시 성능 고려
    - Join, Indexing, SQL Execution Plan
    - 튜닝 사례 - Hash / Join

###  inner join과 outer join의 차이를 설명 
- 이너 조인은 서로 연관된 내용만 검색하는 조인 방법 (교집합)
- 아우터 조인은 한쪽에는 데이터가 없는 경우, 데이터가 있는 쪽의 내용을 전부 출력하는 방법 (합집합)

###  Group By의 역할에 대한 설명 
- group by는 group by 명령어를 통해 특정 컬럼을 기준으로 연산한 결과를 집계 키로 정의하여 그룹을 짓는 역할을 한다.
- 집합 연산자는 COUNT, SUM, AVG, MAX, MIN 등이 있고, DISTINCT와 같이 중복 데이터를 제거하는 특징이 있다.

###  DELETE, TRUNCATE, DROP의 차이를 설명 
- delete는 데이터는 지우지만 테이블 용량은 줄어들지 않고 원하는 데이터만 골라서 지울 수 있다. 삭제 후 되돌릴 수 있다.
- truncate는 전체 데이터를 한번에 삭제하는 방식이다. 테이블 용량이 줄어들고 인덱스 등도 삭제되지만 테이블은 삭제할 수 없고, 삭제 후 되돌릴 수 없다.
- drop은 테이블 자체를 완전히 삭제하는 방식(공간, 인덱스, 객체 모두 삭제)이다. 삭제 후 되돌릴 수 없다.

###  데이터베이스 클러스터링과 리플리케이션의 창이에 대해 설명 
- 클러스터링이란 여러 개의 DB를 수평적인 구조로 구축하는 방식이다. 동기 방식으로 사용됨.
    - 장점
        - DB 간의 데이터를 동기화하여 항상 일관성있는 데이터를 얻을 수 있다.
        - 1개의 DB가 죽어도 다른 DB가 살아 있어 시스템을 장애없이 운영할 수 있다. (높은 가용성)
        - 기존에 하나의 DB 서버에 몰리던 부하를 여러 곳으로 분산시킬 수 있다. (로드밸런싱)
    - 단점
        - 저장소 하나를 공유하면 병목현상이 발생할 수 있다.
        - 서버를 동시에 운영하기 위한 비용이 많이 든다.
- 리플리케이션은 여러 개의 DB를 권한에 따라 수직저긴 구조로 구축하는 방식이다. 비동기 방식으로 사용됨.
    - 장점
        - DB 요청의 60% ~ 80 % 정도가 읽기 작업이기 때문에 Replication만으로도 충분히 성능을 높일 수 있다.
        - 비동기 방식으로 운영되어 지연시간이 거의 없다.
    - 단점
        - 노드들 간 데이터 동기화가 보장되지 않아 일관성있는 데이터를 얻지 못할 수 있다.
        - Master DB가 다운되면 복구 및 대처가 까다롭다.

###  Having과 Where의 차이를 설명 
- having은 그룹을 필터링 하는데 사용되고, where은 개별 행을 필터링하는데 사용된다.
- 집계함수는 having절과 함께 사용할 수 있으나 where 절은 사용할 수 없다.
- having은 그룹화 또는 집계가 발생한 후 필터링하는데 사용되고 where은 발생하기 전에 필터링하는데 사용된다.

###  JOIN에서 On과 Where의 차이를 설명 
- on이 where 보다 먼저 실행되어 join을 하기 전에 필터링을 하고 where은 join을 한 후에 필터링을 한다.

###  HTTP 프로토콜에 대해 설명 
- Hyper Text Transfer Protocol이란 데이터를 주고 받기 위한 프로토콜이며, 서버/클라이언트 모델을 따른다.
- HTTP는 상태 정보를 저장하지 않는 Stateless의 특징과 클라이언트의 요청에 맞는 응답을 보낸 후 연결을 끊는 Connectionless의 특징을 가지고 있다.
- 장점
    - 통신간의 연결 상태 처리나 상태 정보를 관리할 필요가 없어 서버 디자인이 간단하다.
    - 각각의 HTTP 요청에 독립적으로 응답만 보내주면 OK
- 단점
    - 이전 통신의 정보를 모르기 때문에 매번 인증을 해줘야 한다.
    - 이를 해결하기 위해 Cookie나 Session을 사용해서 데이터를 처리한다.

###  HTTP와 HTTPS의 차이점은 무엇? 
- HTTP는 평문 데이터를 전송하는 프로토콜이기 때문에, HTTP로 중요한 정보를 주고 받으면 제 3자에 의해 조회될 수 있다.
- 이러한 문제를 해결하기 위해 HTTP에 암호화가 추가된 프로토콜이 HTTPS이다.
- HTTPS는 SSL의 껍질을 덮어쓴 HTTP라고 할 수 있다.
- HTTP는 원래 TCP와 직접 통신했지만, HTTPS에서 HTTP는 SSL과 통신하고 SSL이 TCP와 통신함으로써 암호화와 증명서, 안전성 보호를 이용할 수 있게 된다.

###  Cookie와 Session의 차이점에 대해 설명 
- Cookie는 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일이다. HTTP에서 클라이언트의 상태 정보를 PC에 저장했다가 필요 시 정보를 참조하거나 재사용할 수 있다.
- Session은 일정 시간동안 같은 사용자로부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 유지시키는 기술이다.
즉, 방문자가 웹 서버에 접속해 있는 상태를 하나의 단위로 보고 그것을 세션이라 한다.

###  www.naver.com에 접속할 때 생기는 과정에 대해 설명 
1. 사용자가 브라우저에 URL을 입력
2. DNS 서버에 도메인 네임으로 서버의 진짜 주소를 찾음
3. IP 주소로 웹 서버에 TCP 3 handshake로 연결 수립
4. 클라이언트는 웹 서버로 HTTP 요청 메시지를 보냄
5. 웹 서버는 HTTP 응답 메시지를 보냄
6. 도착한 HTTP 응답 메시지는 웹 페이지 데이터로 변환되고, 웹 브라우저에 의해 출력

###  TCP와 UDP의 차이를 설명 
- TCP는 연결형 서비스로 3-way handshaking 과정을 통해 연결을 설정하기 때문에 높은 신뢰성을 보장하지만, 속도가 비교적 느리다는 단점이 있다.
- UDP는 비연결형 서비스로 3-way handshaking을 사용하지 않기 떄문에 신뢰성이 떨어지는 단점이 있지만, 데이터 수신 여부를 확인하지 않기 때문에 속도가 빠르다는 장점이 있다.
- TCP는 신뢰성이 중요한 파일 교환과 같은 경우, UDP는 실시간성이 중요한 스트리밍에 자주 사용된다.


###  TCP 통신은 종료시에도 3-way handshaking을 사용하는지? 
- TCP는 3 way-handshaking 과정을 통해 연결을 설정하고, 4 way-handshaking 과정을 통해 연결을 해제한다.

###  3 way-handshake와 4 way-handshake를 설명 
- 3 way-handshake란 TCP 네트워크에서 통신 하는 장치가 서로 연결이 잘 되었는지 확인하는 방법. 송신자와 수신자는 총 3번에 걸쳐 데이터를 주고 받으며 통신이 가능한 상태인지 확인한다.
- 4 way-handshake란 TCP 네트워크에서 통신하는 장치의 연결을 해제하는 방법. 송신자와 수신자는 총 4번에 걸쳐 데이터를 주고 받으며 연결을 끊는다.

###  OSI 7 layer와 각 계층에 대해 아는대로 설명 
- 7계층(응용 계층) : 사용자에게 통신을 위한 서비스 제공. 인터페이스 역할
- 6계층(표현 계층) : 데이터의 형식(Format)을 정의하는 계층 (코드 간의 번역을 담당)
- 5계층(세션 계층) : 컴퓨터끼리 통시을 하기 위해 세션을 만드는 계층
- 4계층(전송 계층) : 최종 수신 프로세스로 데이터의 전송을 담당하는 계층 (단위 : Segment) (ex. TCP, UDP)
- 3계층(네트워크 계층) : 패킷을 목적지까지 가장 빠른 길로 전송하기 위한 계층 (단위 : Packet) (ex. Router)
- 2계층(데이터링크 계층) : 데이터의 물리적인 전송과 에러 검출, 흐름 제어를 담당하는 계층 (단위 : frame) (ex. 이더넷)
- 1계층(물리 계층) : 데이터를 전기 신호로 바꾸어주는 계층 (단위 : bit) (장비 : 케이블, 리피터, 허브)

###  HTTP Method와 각각이 사용되는 경우에 대해서 설명 
- HTTP 메서드는 클라이언트가 서버에게 사용자 요청의 목적을 알리는 ‘수단’이다.
- GET : 데이터 조회
- POST : 요청 데이터 처리 (보통 데이터 등록 사용)
- PUT : 데이터 변경 (해당 데이터가 없으면 생성)
- PATCH : 일부 데이터만 변경
- DELETE : 데이터 삭제

###  GET과 POST의 차이에 대해 설명 
- GET은 데이터를 조회하기 위해 사용되는 방식으로 데이터를 헤더에 추가하여 전송하는 방식. 
URL에 데이터가 노출되므로 보안적으로 중요한 데이터를 포함해서는 안된다.
- POST는 데이터를 추가 또는 수정하기 위해 사용되는 방식으로 데이터를 바디에 추가하여 전송하는 방식.
완전히 안전하다는 것은 아니지만 URL에 데이터가 노출되지 않아 GET 보다는 안전.

###  세션 기반 인증과 토근 기반 인증의 차이에 대해 설명 
- 세션 기반 인증은 클라이언트로부터 요청을 받으면 클라이언트의 상태 정보를 저장하므로 Stateful한 구조를 가지고,
- 토큰 기반 인증은 상태 정보를 서버에 저장하지 않으므로 Stateless한 구조를 가진다.

###  Stateful한 세션 기반의 인증 방식을 사용하게 된다면 어떠한 단점이 있는지 
- 서버에 세션을 저장하기 때문에 사용자가 증가하면 서버에 과부하를 줄 수 있어 확장성이 낮다.
- 해커가 훔친 쿠기를 이용해 요청을 보내면 서버는 올바른 사용자가 보낸 요청인지 알 수 없다. (세션 하이재킹 공격)

###  세션 기반 인증과 토큰 기반 인증은 각각 어느 경우에 적합한가? 
- 단일 도메인이라면 세션 기반 인증을 사용하고, 아니라면 토큰 기반 인증을 사용하는 것이 적합하다고 생각.
- why? → 세션을 관리할 때 사용되는 쿠키는 단일 도메인 및 서브 도메인에서만 작동하도록 설계되어 있기 때문에 여러 도메인에서 관리하는 것은 어렵다 (CORS 문제)

###  JWT 토큰에 대해 설명 
- JWT는 JSON 포맷을 이용하는 Claim 기반의 웹 토큰이며, 토큰 자체를 정보로 사용하는 Self-Contained 방식으로 정보를 안전하게 전달한다.
- JWT는 헤더(Header), 내용(Payload), 서명(Signature)로 구성되며 각 파트를 점(.)으로 구분한다.
    - Header : 토큰의 타입과 해시 암호화 알고리즘(방식지정)으로 이루어져 있다.
    - Payload : 토큰에 사용자가 담고자 하는 정보를 담는다. 내용에는 Claim이 담겨있고, JSON(Key/Value) 형태의 한 쌍으로 이루어져 있다.
    - Signature : 토큰을 인코딩하거나 유효성 검증할 때 사용하는 고유한 암호화 코드이다. 헤더와 내용의 값을 인코딩한다.

###  대칭키, 비대칭키 암호화 방식에 대한 설명 
- 양방향 암호화 방식
- 대칭키는 암호화와 복호화에 같은 암호 키를 쓰는 알고리즘
- 비대칭키는 암호화와 복호화할 때 키를 서도 다른 키로 사용하는 암호화 알고리즘

###  Connection Timeout과 Read Timeout의 차이에 대해 설명 
서버 자체에 클라이언트가 어떤 사유로 접근을 실패했을 시 적용되는 것이 Connection Timeout이다.
즉, 접근을 시도하는 시간 제한이 Connection Timeout 되는 것을 말한다.

클라이언트가 서버에 접속을 성공했으나 서버가 로직을 수행하는 시간이 너무 길어 제대로 응답을 못 준 상태에서 클라이언트가 연결을 해제하는 것이 Read Timeout이다.
이 경우는 클라이언트는 해당 상황을 오류로 인지하고, 서버는 계속 로직을 수행하고 있어 성공으로 인지해 양 사이드간 싱크가 맞지 않아 문제가 발생할 확률이 높다.

###  공인(public) IP와 사설(private) IP의 차이에 대해 설명 
공인 IP는 ISP(인터넷 서비스 공급자)가 제공하는 IP 주소이며, 외부에 공개되어 있는 IP 주소이다.

사설 IP는 일반 가정이나 회사 내 등에 할당된 네트워크 IP 주소이며, 
IPv4의 주소부족으로 인해 서브넷팅된 IP이기 때문에 라우터(공유기)에 의해 로컬 네트워크상의 PC나 장치에 할당된다.

사설 IP 주소만으로는 인터넷에 직접 연결할 수 없고, 라우터를 통해 1개의 공인 IP를 할당하고 ,라우터에 연결된 개인 PC는 사설 IP를 각각 할당 받아 인터넷에 접속 할 수 있다.

### 참고
https://dev-coco.tistory.com/163

https://zero-base.co.kr/event/media_BE_school_qna

https://selgii.tistory.com/49

https://github.com/cracking-interview/be-interview?tab=readme-ov-file